# Maintainability

* Maintenance of software contributes to the majority of its cost - fixing bugs, adapting to new platforms, modifying for new use cases, adding new features etc.
* We should design software in such a way that it will make maintenance easier. These design principles should help:
  * operability - make it easy for ops teams to keep the system running smoothly.
  * simplicity - make it easy for new engineers to understand the system.
  * evolvability - make it easy for engineers to make changes to the system in the future, adapting to unanticipated use cases as requirements change.
* Operability indicates the ease with with the operations team can keep running the system smoothly. Automation should be created to ensure that the software system works correctly.
* A good operations team is reponsible for - monitoring the health and quick restoration of the system, tracking down root causes for system failures or degraded performance, keeping software platforms up to date including security patches, keep track of how different systems affect each other, capacity planning, establishing good practices for deployment, config management, performing complex maintenance tasks, maintaining security of the system with different changes and preserving the knowledge of the system and operations.
* Software that is operable with ease will allow operations team to focus the efforts on high-value activities. Routine tasks can be made easy by doing things such as providing visibility into runtime behavior, providing automation support and integration, avoiding dependency on individual machines for decent performance, providing good documentation, self healing when appropriate etc.
* Simplicity indicates the ability for new engineers to understand the system by removing complexity around the system. Complexity in a software project can have various symptoms - tight coupling of modules, tangled dependencies, inconsistent naming, hacks instead of design changes, adding many special cases for many issues etc. Complexity makes everything hard - budgets, scheduling, more likelyhood of bugs, maintenance cost etc.
* Making a software system simpler doesn't mean to reduce functionality - it can mean to remove accidental functionality. [Moseley and Marks](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.93.8928) define complexity as accidental if it is not inherent to the problem that the software system solves but arises only from implementation. One tool to remove complexity is abstraction - it can hide a great deal of implementation behind simple classes. It also allows software classes and methods to be reused.
* Finally, evolvability indicates the ease with which software system can change to fit future requirements or changes in existing requirements. Organizations use Agile methodology and patterns such as TDD, refactoring to adapt to frequent change.
